# next.js open tutorials notes

# next.js란?

react 기능들을 기반으로 한 풀스택 웹 애플리케이션 프레임워크

- FE -> react
- BE -> expressjs 유사 시스템 기본 탑재

장점
- server-side rendering(SSR) 지원
  - client-side rendering: react와 같은 js 기반의 애플리케이션은 js로 동작하기에, js를 다운로드 한 후 브라우저에서 js가 실행되어야 화면에 ui가 표시 -> js가 동작하지 않는 환경에서는 화면이 표시되지 않기 때문에 검색엔진과 같은 로봇들이 컨텐츠를 이용할 수 없다는 치명적 단점 + js를 다운로드하고 실행하기 전까지는 화면이 표시 불가 문제
  - SSR은 서버 쪽에서 js 쪽에서 js가 실행, 브라우저로 완성된 html 전송 -> js를 실행할 수 없는 환경에서도 동작, 검색엔진 친화적 + 다운로드 받는 즉시 표시되기에 사용자 입장에서도 빠른 속도의 웹페이지 느낌 경험

기타
- app router: nextjs 13 버전부터 적용된 새로운 매커니즘 -> 'server component'라는 새로운 react 기능 활용
- 필요 react 선수지식: component, state, props, useEffect






</br></br></br>

# 설치와 실행

설치
- node.js 설치(홈페이지 다운로드)
- 폴더 생성 -> IDE에서 폴더 오픈 -> 터미널
  `npx create-next-app@latest .`(npx: 노드로 만들어진 프로그램을 설치 없이 바로 실행 가능)
    - `src/` directory? -> yes
    - App Router? -> yes(nextjs 13 버전부터 도입, 큰 변화. nextjs 13버전 이전에는 Page Router라는 걸 사용.)
    - import alias -> no
    - (nextjs가 설치 안되어 있는 컴퓨터는 이 과정을 꼭 한 번 실행해야 제대로 설치가 된다. 아래 커맨드는 실행해도 설치는 된 것으로 보이지만 npm run start 등의 커맨드를 찾지 못하는 문제가 발생한다.)
      - `npm install -g create-next-app` 혹은 `sudo npm install -g create-next-app`
- `npm run dev`(`npm run start`는 `create-react-app`에서 사용)


기타





</br></br></br>

# 샘플앱 세탁

- `layout.js` - 기본적인 웹페이지 골격 구성


```js
// layout.js
import "./globals.css";

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
      </body>
    </html>
  );
}

```

`children`의 내용은 `page.js`에서 가져온다.

```js
// page.js
export default function Home() {
  return (
    <>
      hello, nextjs!
    </>
  );
}
```

`global.css` 내용 전부 삭제 초기화






</br></br></br>

# 배포

`npm run dev` 시...
- 실서버에 최적화된 버전이 필요
  - chrome 개발자도구 -> network -> 맨 밑 보면 '6.9MB resources' 라고 나온다. -> 서버에서 클라이언트로 전송한 용량. 큰 용량. -> 줄이는 게 바람직
  - 추가로 chrome 개발자도구 console창 보면 개발을 위해 필요한 여러 정보들이 출력이 된다(초기에는 없지만) -> 배포시 비효율적이고, 보안상 문제 가능성 -> 없는 게 바람직
- `package.json`: nodejs 기반 프로젝트들은 "scripts" 하위에 프로젝트 유지보수를 위한 명령어들 목록
  - `"dev": next dev` - `npm run dev` 시 "next dev"라는 명령어 실행
  - `"build: "next build"` - 실서버를 위한 배포판을 만드는 명령
    - 패키지에 `.next` 폴더 및 소스 생성 -> 개발을 하건, 실서버를 빌드하건, 사용자들에게 서비스되는 내용이 저장된다.
  - `"start": "next start` - 그 배포판을 서비스하는 명령
    - `npm run build`(배포판 빌드) -> `npm run start`(배포판 실행) -> `.next` 패키지에 있는 내용이 서비스되기 시작
- build 후 배포판 서버 실행시 chrome 개발자도구 network에서 '376 kb resources'라고 나오는 걸 확인할 수 있다(6.9MB -> 376 kb, 약 20배 용량 감소).





```js
```





4/3.03:30 81%
4/3.21:44 78%
01:35 45%

</br></br></br>

# 뼈대 만들기

어떤 페이지를 가도 공통으로 있는 내용들은 `layout.js`에서 다루는 게 효율적

(참고)웹페이지의 메타데이터는 약속된 이름의 상수 `metadata`를 export해 설정할 수 있다.
```js
export const metadata = {
  title: "WEB TUTORIALS",
  description: "Generated by LFTY",
};
```







</br></br></br>

# 라우팅

`http://a.com/dashboard/analytics`
- `a.com` - domain
- `dashboard`, `analytics` - segment
- `/dashboard/analytics` - path

path가 주어지지 않으면 nextjs는 src/app 밑에서 `page.js`가 있는지를 찾는다 -> `page.js`의 return 값을 `layout.js`의 children에 결합해 최종적인 html을 응답하도록 한다.

src/app 아래에 path에 대응하는 폴더를 만들고 그 안에 `page.js`를 작성
```js
// http://192.168.1.16:3000/create
// src/app/create/page.js
export default function Create() {
  return <h2>create, create, create!</h2>;
}
```
동작 원리
1. `/create`로 접속을 하게 되면 nextjs는 app 폴더 밑에 create 폴더가 있는지 탐색
2. 그 폴더가 `page.js`를 갖고 있는지 탐색
3. 있다면 해당 내용을 create 폴더 밑에 `layout.js`가 있는지 탐색
4. 있다면 그것에 결합, (보통)없으면 그 부모 폴더로 가서 `layout.js`가 있는지 탐색
5. 있다면 해당 내용이 `children` 위치에 결합하고 그 결과를 응답

create 밑에 여러 개의 페이지가 있다면 create에 `layout.js`가 있는 게 좋을 수 있다.
```js
// src/app/create/layout.js
export default function Layout(props) { // props가 있어야
    return (
        <div>
            <h2>create</h2>
            {props.children}
        </div>
    )
}
```
1. src/app/create 폴더 아래의 `page.js`가 동일 폴더 `layout.js`에 결합되고, 
2. 이후 부모 폴더인 src/app 아래에 `layout.js`가 있는지 탐색하고 있다면 지금까지 만들어진 content를 부모의 `layout.js`의 children 부분에 결합한다.


### dynamic routing

uri path에 parameter가 무엇이 들어올지 알지 못하는 상태에서 해당 페이지를 라우팅 하려면? -> 동적 라우팅

```js
// http://192.168.1.16:3000/read/1(어떤 숫자가 올지 모름)
// src/app 아래에 read 폴더 생성, 그 아래에 [id] 폴더 생성, 그 아래에 page.js 생성
// src/app/read/[id]/page.js
export default function Read(props) {
    return (
        <>
            <h2>read</h2>
            {props.params.id}
        </>
    )
}
```







</br></br></br>

# single page application

웹페이지가 여러 개의 페이지임에도 불구하고 마치 한 페이지인 것처럼 동작하는 애플리케이션을 single page application이라 한다.

### server side rendering

nextjs의 큰 장점 중 하나
- chrome 개발자도구 → menu(…) → run command → ‘disable javascript’ 선택 → 그래도 페이지는 전달 되는 걸 확인할 수 있다.
  - 되돌릴 땐 ‘enable javascript’
- 리액트는 js 기술이기 때문에 js가 동작하지 않으면 아예 렌더링이 되지 않는다. 하지만 nextjs로 만든 페이지는 브라우저에서 js를 비활성화해도 렌더링이 잘 되는 모습을 볼 수 있다.
  - 사용자가 요청하면 `.next` 폴더에 nextjs가 서버 쪽에서 react를 실행해서 그 응답 결과를 `.next`에 저장해서 그것을 응답하기 때문.
  - 즉, nextjs는 js가 아닌 html을 응답.


nextjs의 단점 중 하나
- chrome 개발자도구 → network → ‘not throttling’을 ‘3G’ 등으로 바꿔 일부러 네트워크 지연현상을 만들 수 있다.
- 페이지 reload마다 페이지 전체 새로 로드하는 문제(대역폭 증가=비용 증가, 속도 저하)
- 해결 방법: `<a>`대신 `<Link>` 컴포넌트 활용
  - 한 페이지 안에 여러 링크 정보가 있으면 prefetch를 통해 백그라운드에서 미리 해당 링크의 페이지 데이터들을 읽어오며,
  - 미리 읽어왔거나 이미 방문한 페이지를 재방문할 시에는 서버와 통신도 하지 않는다 -> 사용자는 빠른 사용자 경험, 서비스 제공자는 비용절약

```html
<!-- <a href=...></a>  -->
<Link href=…></Link>
```

### 문제 발생

- (참고 - 강의 코멘트 중)nextjs에 업데이트가 있었는지 개발환경에서는 미리 데이터를 읽어오는 prefetch 기능이 작동하지 않는 것 같습니다. 대신 `npm run build && npm run start`를 해서 배포판을 실행하면 화면에 링크가 노출되는 것만으로도 미리 데이터를 받아오네요.
  - 하지만 이 역시 실제 실행해보면 링크들의 데이터를 미리 읽어옴에도 불구하고, 그리고 재방문시에도 매번 새로 데이터를 읽어옴을 알 수 있다...왜?
    - 정적 페이지들은 prefetch후 방문시 서버와 통신 안하고 바로 읽어옴. 동적 라우팅 연관 페이지들은 요청시마다 불러옴.

```json
// nextjs 버전 현황
{
 "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "15.2.4"
  }
}
```

조사 결과:
1. 정적 생성 누락
  - 동적 라우트([id])를 사용하면서도 generateStaticParams가 정의되지 않았습니다.
    - Next.js는 기본적으로 동적 라우트를 SSR(서버 사이드 렌더링) 로 처리합니다.
    - 매번 서버에서 페이지를 생성하므로, 재방문 시에도 새로 요청이 발생합니다.
2. Prefetch의 한계
  - <Link>의 prefetch는 페이지의 JavaScript 번들만 미리 로드합니다.
  - 동적 라우트의 데이터가 서버에서 처리되는 경우(예: getServerSideProps), 실제 데이터는 페이지 방문 시점에 요청됩니다.
3. 해결 방법
  1. 정적 사이트 생성(SSG) 설정
    - 동적 라우트를 빌드 시 정적 페이지로 생성하도록 설정합니다.
  2. 외부 데이터 사용 시 캐싱
    - 만약 외부 API에서 데이터를 가져오는 경우, 캐싱 정책을 명시합니다.
  3. 개발/프로덕션 환경 확인
    - 개발 환경(npm run dev) 에서는 prefetch가 기본적으로 비활성화됩니다.
    - 프로덕션 빌드(npm run build && npm run start) 에서만 prefetch가 정상 작동합니다.
4. 최종 동작 검증
  1. generateStaticParams를 추가하고 npm run build 실행 → /read/1, /read/2가 .next/server/app/read에 정적 파일로 생성됩니다.
  2. 프로덕션 서버(npm run start)에서 테스트:
    - 첫 방문: 정적 페이지 제공
    - 재방문: 캐시된 페이지 사용 (네트워크 요청 없음)
  3. <Link>의 prefetch가 활성화된 경우, 링크가 뷰포트에 노출될 때 미리 페이지를 로드합니다.








</br></br></br>

# 정적 자원 사용하기

이미지와 같은 정적인 콘텐츠는 `public` 폴더에 위치시킨다.
- 이미지 경로는 `/`를 입력하면 `public`을 자동으로 가리키게 된다.
```js
export default function Home() {
  return (
    <>
      <h2>WELCOME - src/app/page.js</h2>
      <br />
      <img src="/lftyc.png" ></img>
    </>
  );
}

```







</br></br></br>

# CSS

root layout 파일의 `import "./globals.css";` -> `global.css` 수정하면 전역적으로 스타일 적용

```css
// global.css 예
h1 a {
    text-decoration: none;
    color: black;
}
```












</br></br></br>

# 


```css

```







</br></br></br>

# 


```js
```


4/4.02:30 83%


npx json-server --port 9999 --watch db.json
(db.json 생성 안되고 서버 실행 안될시 아래로 실행)
npx json-server@0.17.4 --port 9999 --watch db.json








</br></br></br>

# backend

실습 편의 위해 json-server 사용

(nextjs를 순수히 백엔드로만 사용하거나 api를 구축하고 싶다면 docs의 'route handlers' 참고)

`npx json-server --port 9999 --watch db.json`
- `db.json`이라는 파일 생성후 실행
- `--watch db.json`: db.json이라는 파일에 정보를 저장하고, 변경이 생길시 바로 서버에 반영, 바로 서버 재시동(현재는 --watch 옵션 안넣어도 디폴트로 해당 기능 수행--watch/-w can be omitted, JSON Server 1+ watches for file changes by default)

chrome 개발자도구 console창에:
```js
fetch("http://localhost:9999/topics")
    .then((resp)=>{
        return resp.json();
    }) // json으로 되어있는 응답을 javascript로 변환
    .then((result)=>{
        console.log("result", result);
    })
```








</br></br></br>

# 글 목록 동적으로 가져오기

react 18버전부터 server component라는 개념 추가. nextjs에서도 server component와 client component라는 개념 구분. 서로 사용할 수 있는 api가 다르다(server component에서 client component 사용시 오류 발생). nextjs에선 특별한 조치가 없는 한 기본적으로 모든 컴포넌트를 server component로 간주.
- server component:
  - secure data
  - cookie
  - header
- client component:
  - useState
  - useEffect
  - onClick
  - onChange
  - useRouter
  - useParams
- in both:
  - fetch

### 언제 무엇을 사용하나?
- 화면에서 사용자와 상호작용하지 않는 부분은 server compoenent가 유리, 상호작용하는 부분만 client componet로.

```js
// layout.js
"use client" // layout.js를 client component화
import "./globals.css";
import { useState, useEffect } from "react";

export const metadata = { // metadata는 server component에서만 사용 -> error 발생
  title: "WEB TUTORIALS",
  description: "Generated by LFTY",
};

export default function RootLayout({ children }) {
  const [topics, setTopics] = useState([]);
  useEffect(() => {
    fetch("http://localhost:9999/topics")
      .then(resp=>resp.json())
      .then(result=>setTopics(result));
  });

  return (...);
}
```

### 문제점
```js
useEffect(() => {
  fetch("http://localhost:9999/topics")
    .then(resp=>resp.json())
    .then(result=>setTopics(result));
});
```
1. 서버에서 데이터를 가져올시 비효율 발생 가능(eg.서울 클라이언트 <-> 상파울루 서버 통신)
2. js가 동작불가일 시 서버와 통신하는 `userEffect()` 등 js 코드들은 실행되지 않기 때문에 클라이언트 화면에도 보이지 않을 수 있다.
3. 서버에서 가져온 id/비밀번호 등 민감한 정보가 노출되고 보안 문제를 일으킬 수 있다.






</br></br></br>

# 


```js
```









</br></br></br>

# 


```js
```







</br></br></br>

# 


```js
```







</br></br></br>

